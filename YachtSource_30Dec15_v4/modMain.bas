Attribute VB_Name = "modMain"
'GoProgram State added to StartTimeIsSet
Option Explicit

'Public Const cbDefault = &H8000000F
Public Const cbEnabled = vbYellow
Public Const cbDisabled = &H8000000F

Private Declare Function SafeUDTGetDim Lib "oleaut32" Alias "SafeArrayGetDim" (pArray As Any) As Long
Private Declare Function SafeArrayGetDim Lib "oleaut32" (pArray() As Any) As Long

Public Declare Function ShellExecute _
                            Lib "SHELL32.DLL" _
                            Alias "ShellExecuteA" ( _
                            ByVal hwnd As Long, _
                            ByVal lpOperation As String, _
                            ByVal lpFile As String, _
                            ByVal lpParameters As String, _
                            ByVal lpDirectory As String, _
                            ByVal nShowCmd As Long) _
                            As Long

'Public Declare Function Beep Lib "kernel32" (ByVal dwFreq As Long, ByVal dwDuration As Long) As Long

Public cbOrange As Long
Private PreciseClock As clsTimer

Public Type defLink
    Type As String  'UpLink or DownLink (Replaces using UpLink & DownLink)
    Flag As Long    'The Link Flag that is associated
    Raise As Boolean    'True = Raise Linked Flag, False=Lower Linked Flag
End Type

Public Type defFlag  'Properties where to display the Image (Blank if not displayed)
    pos As Long         'Flag(idx) = 0 if not Up (Both Row & Col > 0)
    Row As Long         'Row on which to display the flag,  Set on UP, Clear after down
    Col As Long         'Col on which to display the flag
    FixedRow As Long 'Position is preset on load, so do not clear on event
    FixedCol As Long
    Queue As Boolean    'Queue any Flag Event (Sounds, Controllers), do not clear on event
    Changed As Boolean  'Used to generate Controller Event  'Clear after event handled
End Type

Private Type defGroupDefault  'Are applied to the above when Signal Is Loaded (by LoadProfile)
    Group As String     'Group to which these defaults are applied
    FixedRow As Long
    FixedCol As Long
    Queue As Boolean
End Type

Private Type defController
    Name As String
    IpAddress As String
    On As String
    Off As String
    State As Boolean    'True = should be on
    Connection As String
    Sound As String
End Type

'Public Type defGroup    'Only defined for Fixed Groups (Sound, Lights)
'    GroupName As String
'    Queue As Boolean    'Process signals sequentially
'End Type

Private Type defSignalAttribute 'Initialled loaded from .ini file [Signal] section
'These are defined again as they are used once the timer is
'running - they are loaded from the UpDown
'These are the same for OFF and ON
    Type As String  'Class, Finish, Sound, Recall
    Name As String  'Name of the Signal  Class Flag 1
    Image As Picture    'GIF image
    Flag As defFlag   'Flag Attributes
    Group As String  'Flag is positioned below any UP Flag in this Group
    Class As Long    '-1 = none Classes(Csidx) to speed access in DoTimerEvents
    TTL As Long     'Time this flag is displayed in Millisecs
                    'It will be off for the same Period (if more than 1 cycle)
    CyclesRequired As Long  'No of On cycles by timer before creating OFF event
    OnCycles As Long    'Count of on cycles, completed after next off(when timer is enabled)
    TTD As Long         'Time Off
    ImageFilePath As String 'Flag Image
                            'timer must be unique
    Links() As defLink   'Used when signal is Raised(UP) & when Lowered(Down)
    Controller As Long  'This is the controller used when the flag is visible
                        '-1 = no linked controller
    Silent As Boolean   'Set by DoTimerEvents if Sound Signals are not generated by the link
                        'Must be unset by DoTimerEvents as well
End Type

Private Type defSignalEvt
'    Class As Long
    Signal As Long
    Raise As String         'Up, Down or ""     'Cannot be defined as Boolean
    Silent As String        'True, False or ""  'as we wanny tell if it wants leaving or changing
End Type

Private Type defButtonEvt
'    Class As Long
    Button As Long
    Enabled As String       'True, False or "" (dont change)
End Type

Private Type defFunctionCallEvt
    Index As Long
    Name As String
End Type

Private Type defEvt
    ElapsedTime As Long
    Class As Long
    Signal As Long
    Message As String
    Signals() As defSignalEvt
    Buttons() As defButtonEvt
    FunctionCalls() As defFunctionCallEvt
    Focus As Long           'Idx of Command button to give focus to (0)=none
                            'Note BackColor wants cnaging to Green if it was Default
End Type

Private Type defClass       'These are extracted when the Events are loaded
    Name As String          'Same as Signal and Command Caption
    Signal As Long          'Idx of Class Signal
    Warning As Long         'First Signal when Class Flag is raised
    start As Long           'Time when Class cannot be postponed
                            'Time when Class can be recalled
    Offset As Long          'Offset to all class times due to Postponement
                            'or Recall
End Type

Private Type defStart
    Last As Long    'Last Class Started (even if Recalled or Postponed after recall)
                    'Will be same as Next if General Recalled
    Next As Long    'Next Class to start
End Type

Private Type defKey
    KeyName As String   'F1,F6
    Code As Long        '116,119
    State As Long  '0=Disabled,1=Postpone,2=Recall,3=General Recall, 4=Finish
    Cancel As Boolean   'If True next press will Lower the flag
'None,GoRaisePostpone,GoLowerPostpone,GoRaiseRecall,GoLowerRecall
'GoRaiseGeneralRecall,GoLowerGeneralRecall,GoRaiseFinish
    FunctionCall As String
End Type

Public Type defState    'Public so we can save it, General Recall changed to Postpone
    Program As Long     '0=No Profile,1=Loading Profile,2=Profile Loaded
                        '3=Start Time Set,4=Start Sequence Commenced,5=Start Sequence Finished
    Sequence As Long    '0=Disabled,1=NotStarted,2=Postpone,3=Recalls,4=Finish
    Recalls As Long     '0=None,1=Both,2=Recall,3=General Recall
    StartClass As defStart   'NextClass, LastClass
    EventPause As Long  '-1=indefinite, 0 = not paused, 60 = for 60 secs
    NextEventTime As Long   'The current timer event we are processing
                            'Incremented when we have processed the Events
'    FunctionClass As Long   'Used for Postpone & Recalls else 0
    GrStartTime As Long   'IOnly to display Time since General Recall Start
End Type

Private Type defFunctionKey
    KeyNo As Long
End Type

Public CurrentProfile As String     'The Current Sequence selected
Public Loading As Boolean   'Suppress Queueing Commands, and Flag Position errors

Public StaticCommands() As Boolean  'CommandButtons defined in the initially loaded form
                                    'True = dont reposition
Public Controllers() As defController
Public SignalAttributes() As defSignalAttribute
Public Evts() As defEvt
Public Classes() As defClass
Public Keys() As defKey     'Keys(0)=Unused, Keys(1)=F5, Keys(2)=F8
Public State As defState
Public aProgramState(0 To 5) As String
Public StateToKeyIdx(0 To 4) As Long
Public aSequenceState(0 To 4) As String
Public aRecallsState(0 To 3) As String
Public aKeyState(0 To 4) As String
Public RecallSignalIdx As Long   'The Flag index used for recalls
                                'Must be defined as a signal (normally 10)

'Public ElapsedTime As Long  'Seconds before or after start time
Public RowCount As Long
Public ColCount As Long
Public ColCountFree As Long 'ColCount less any Fixed Cols
Public SignalImageFilePath As String
Public SequencesFilePath As String
'This is the same as in Inno
'XP = C:\Documemts and Settings\All Users\Application Data\
'Win10 C:\ProgramData\
Public CommonAppData As String

'These MUST be separate because Eidx is in scope when LoadRecall is called
'Dim Eidx As Long    'Evts(Eidx) index   base = 0, -1 = not open
'Sidx has separate args passed when loading
'Must set Sidx to -1 when Signal= is seen in an Event section
'And hang on to it until a new Signal= is seen
Private Sidx As Long

'These are the variables that are set up in the [Profile] section
Private RecallControl As Boolean    'Not used
Private ButtonControl As Boolean    'Not used
Private ButtonEvents As Boolean     'Enable Events Button (make visible)
Private ClassSilenceControl As Boolean 'Silence Class Flags raised at same time as a Class Flag is Lowered
Public SoundOnAllFinishers As Boolean   'SYC Default is False
Public SkipClassOnRecall As Boolean     'SYC Default is False
Public Multiplier As Long               'Speed up events for testing

'Required by by Load Profile & ParseProfile
Private GroupDefaults() As defGroupDefault
Private RecallTemplate() As String
Private ClassTemplate() As String
Private EventClassName As String    'The Class the Events created relate to
Private ClassStartElapsedTime As Long

Sub Main()
Dim i As Long

    On Error GoTo Main_Error
    If App.PrevInstance Then
        MsgBox "RacingSignals is already running" & vbCrLf & "You cannot have it running twice on the same PC", vbCritical, "Racing Signals"
        GoTo Main_Exit
    End If
    LogFileCh = -1  'force open for output
    
    Call WriteLog("Environment Settings")
    i = 1
    Do
        Call WriteLog(Environ(i))
        i = i + 1
    Loop Until Environ(i) = ""
    
'There is no envirinment variable to get the ALL USERS\Application Data location
'internationally Application data is re-named si the english must NOT be used

    CommonAppData = GetSpecialFolderA(CSIDL_COMMON_APPDATA)
    Call WriteLog("GetSpecialFolder CSIDL_COMMON_APPDATA = " & CommonAppData)
    Call WriteLog("Windows Version = " & GetVersion1())
    Call WriteLog("User Default LocaleID = " & GetUserDefaultLCID())
    Call WriteLog("Decimal Separator = " & GetDecimalSeparator)

    Call WriteLog("User has Administrator Rights = " & CBool(IsNTAdmin(ByVal 0&, ByVal 0&)))

    Call WriteLog("***************")
    
    
    WriteLog App.EXEName & ".exe " & App.Major & "." & App.Minor & "." & App.Revision & " Started"
    If Is64bit Then
        WriteLog "Version = " & GetVersion1() & " (64 bit)"
    Else
        WriteLog "Version = " & GetVersion1() & " (32 bit)"
    End If

    WriteLog "Install log = " & Environ("USERPROFILE") & "\Local Settings\Temp\Setup Log [install date] #[sequence no].txt"
'    Action.Load (Environ("AllUsersProfile") & "\Application Data\Arundale\RacingSignals\Sequences\" & "ScarboroughMultiple.csv")
    'SignalImageFilePath = Environ("AllUsersProfile") & "\Application Data\Arundale\RacingSignals\SignalImages\"
    SignalImageFilePath = CommonAppData & "Arundale\RacingSignals\SignalImages\"
    WriteLog "SignalImageFilePath = " & SignalImageFilePath
    'SequencesFilePath = Environ("AllUsersProfile") & "\Application Data\Arundale\RacingSignals\Sequences\"
    SequencesFilePath = CommonAppData & "Arundale\RacingSignals\Sequences\"
    WriteLog "SequencesFilePath = " & SequencesFilePath
    
    
    cbOrange = RGB(255, 102, 0) '    RGB(255, 153, 0)
    Multiplier = 1
    RecallControl = True
    ButtonControl = True
    ClassSilenceControl = True
    aProgramState(0) = "No Profile"
    aProgramState(1) = "Loading Profile"
    aProgramState(2) = "Profile Loaded"
    aProgramState(3) = "Start Time Set"
    aProgramState(4) = "Start Sequence Commenced"
    aProgramState(5) = "Start Sequence Finished"
    aSequenceState(0) = "Disabled"
    aSequenceState(1) = "Not Started"
    aSequenceState(2) = "Postpone"
    aSequenceState(3) = "Recalls"
    aSequenceState(4) = "Finish"
    aRecallsState(0) = "None"
    aRecallsState(1) = "Both"
    aRecallsState(2) = "Recall"
    aRecallsState(3) = "General Recall"
    aKeyState(0) = "Disabled"
    aKeyState(1) = "Postpone"
    aKeyState(2) = "Recall"
    aKeyState(3) = "General Recall"
    aKeyState(4) = "Finish"
    
    Set PreciseClock = New clsTimer
    
    WriteLog "Loading frmMain"
    
    Load frmMain

'We can use the ClubBurgee to control who it is licenced to
   frmMain.ClubBurgee.Picture = LoadPicture(SignalImageFilePath & "ClubBurgee.gif")

'You cannot setfocus while the form is loading
'This prevents the cboProfile being displayed in Blue
'    frmMain.txtFirstStartTime.SetFocus
    WriteLog "Loading frmDaventech"
    Load frmDaventech
    If frmMain.cboProfile.ListCount = 0 Then
        Unload frmMain  'exit program
    Else
        frmMain.Show
    End If
    
    WriteLog "frmMain.DisplayProgram"
    Call frmMain.DisplayProgram
    WriteLog "frmMain.DisplaySequence"
    Call frmMain.DisplaySequence
    WriteLog "frmMain.DisplayRecalls"
    Call frmMain.DisplayRecalls
'remove functionkeys    Call frmMain.DisplayKeys
    WriteState "Main"
'    Call SetProgramState(1)
Main_Exit:
Exit Sub

Main_Error:
    Select Case Err.Number
    Case Else
        MsgBox "Error " & Err.Number & " - " & Err.Description, vbCritical, "Main_Error"
    End Select
    Resume Next 'Only in sub Main (otherwise application does not terminate)
'    Resume Main_Exit
    
End Sub
'False if it fails

Public Function TimerOutput(OutputTime As Date) As Boolean
'Debug.Print Format$(OutputTime, "hh:mm:ss")
    TimerOutput = True
End Function

'Converts a Nul string to "0"
Public Function NulToZero(TxtIn As String) As String
    If TxtIn = "" Then
        NulToZero = "0"
    Else
        NulToZero = TxtIn
    End If
End Function

Public Function LoadProfile()
Dim DecryptedFileName As String
Dim EncryptedFileName As String
Dim ch As Long

Dim Section As String   'Signal=nnn
Dim Idx As Long   'Signal is the only section requiring an index (at the moment)
Dim Eidx As Long    'Evts(Eidx) index   base = 0, -1 = not open
Dim Lidx As Long    'SignalAttributes(Idx).Links(Lidx).Index
Dim Cidx As Long    'Controller() index
Dim Csidx As Long   'Classes(index) index=0 if no class starting
Dim Fcidx As Long   'Event index for FunctionCalls

Dim Template As String
Dim ElapsedTime As Long

Dim i As Long
Dim j As Long
Dim Secs As Long
Dim nextline As String
Dim CleanLine As String
Dim LineType As String
Dim CleanSection As String
Dim arry() As String    'Name=Values (Multiple Values Comma separated)
Dim arry1() As String   'Values in arry(1)
Dim MySignalTimer As Timer
Dim MyFont As New StdFont
Dim MyPicture As New StdPicture
Dim MyFrame As Frame
Dim MyLink As defLink
Dim SectionError As Boolean

Debug.Print "==============="

WriteLog "LoadProfile " & CurrentProfile

    On Error GoTo LoadProfile_err
'Check of profile has been selected
    If CurrentProfile = "" Then
        Exit Function
    End If
'    Call SetState("Program", 1)
    Loading = True
'Clear existing profile
    Unload frmEvents
'Set up Controller(0) for the Horn, even if nothing connected
    ReDim Controllers(0)
    ReDim SignalAttributes(1 To 1)  'this will clear the array
    Erase Evts
    ReDim GroupDefaults(0)
    ReDim RecallTemplate(0)
    ReDim ClassTemplate(0)
    ReDim Classes(0)    'CsIdx
    Classes(0).Name = "All Classes"
'Set these up in the Profile
    ReDim Keys(3)   'Change to 0
    Keys(1).Code = 116
    Keys(1).KeyName = "F5"
    Keys(2).Code = 119
    Keys(2).KeyName = "F8"
    Keys(3).Code = 123
    Keys(3).KeyName = "F12"
    StateToKeyIdx(0) = 0    'No of Function keys in use
    StateToKeyIdx(1) = 1
    StateToKeyIdx(2) = 1
    StateToKeyIdx(3) = 2
    StateToKeyIdx(4) = 1
'Must be done after classes cleared because when starttime is cleared
'the start times in classes (if any) are displayed
    Call frmMain.ClearProfile
    
    Eidx = -1
    SoundOnAllFinishers = False 'If not defined as true in .ini
    SkipClassOnRecall = False 'If not defined as true in .ini
'    Sidx = -1
'    Bidx = -1
'Set up Controller(0) for the Horn, even if nothing connected
'Min of 1 controller
'    Call frmMain.ResetProfile
'    Call frmMain.ResetSignalTimers
'    Call frmMain.ResetCommands
'    Call frmMain.ResetFlags
'    Call frmMain.ResetFinish
'    Call frmMain.ResetRecall
    Call frmDaventech.OpenAndSend("")
'    Call frmMain.ResetEvents no longer required
'Set up new profile
'    frmMain.Caption = App.EXEName & " [" & App.Major & "." & App.Minor & "." _
'    & App.Revision & "] " & frmMain.cboProfile.List(frmMain.cboProfile.ListIndex)
    
'Change name to ClubBurgee    'requires putting in profile
'MsgBox SignalImageFilePath
'   frmMain.ClubBurgee.Picture = LoadPicture(SignalImageFilePath & "SycBurgee.gif")

    
    EncryptedFileName = SequencesFilePath & frmMain.cboProfile.List(frmMain.cboProfile.ListIndex) & ".ini"
    DecryptedFileName = Replace(EncryptedFileName, ".ini", ".tmp")
    Call DecryptFile(EncryptedFileName, DecryptedFileName)
WriteLog "Opening " & DecryptedFileName
 ch = FreeFile
    Open DecryptedFileName For Input As #ch
    Do Until EOF(ch)
        Line Input #ch, nextline
WriteLog nextline
        CleanLine = nextline
        LineType = CleanProfileLine(CleanLine)   'NextLine is cleaned
        If LineType = "Skip" Then
            GoTo Skip_line
        End If
 Debug.Print CleanLine
        arry = Split(CleanLine, "=")
'If we're reading in a template, then we do not action Open of Close
'at this time (we do it when LoadRecallEvent is processsd)
        If Section = "Template" And arry(0) <> "/Template" Then
                LineType = "Update"
            Else
'Stop
        End If
        Select Case LineType
'OPEN
        Case Is = "Open"
            Section = arry(0)
            Select Case Section
            Case Is = "Profile"
            Case Is = "Class"
                Csidx = Csidx + 1
                If Csidx > UBound(Classes) Then
                    ReDim Preserve Classes(Csidx)
                End If
                If SignalFromName(arry(1)) > 0 Then
                    Classes(Csidx).Name = arry(1)
                    Classes(Csidx).Signal = SignalFromName(arry(1))
                    SignalAttributes(Classes(Csidx).Signal).Class = Csidx
                    EventClassName = arry(1)
                Else
MsgBox "Class Name in [Event=" & arry(1) & "] is not defined as Signal Name", vbCritical, "LoadProfile"
                End If
            Case Is = "Template"
                Template = arry(1)
                Select Case Template
                Case Is = "Recall"
                    RecallTemplate(0) = "'Recall Template"
                Case Is = "Class"
                    ClassTemplate(0) = "'ClassTemplate"
                Case Else
MsgBox "Template array " & arry(1) & " doesnt exist", vbCritical, "Parse Profile"
                
                End Select
            Case Is = "Event"
                If Eidx = -1 Then
                    Eidx = EventOpen(CLng(arry(1)) / Multiplier)
                Else
MsgBox "Event not Closed", vbCritical, "EventOpen"
                    GoTo Skip_line
                End If
            Case Is = "Controller"
'Arry1 contains the Controller index
                If IsNumeric(arry(1)) Then
                    Cidx = arry(1)
                    If Cidx > UBound(Controllers) Then
                        ReDim Preserve Controllers(Cidx)
                    End If
                End If
                Controllers(Cidx).Name = "Controller (" & Cidx & ")"
            Case Is = "Signal"
                Lidx = 0
                If IsNumeric(arry(1)) Then
                    Idx = arry(1)
'Create the Signal Attributes array index
                    If Idx > UBound(SignalAttributes) Then
                        i = UBound(SignalAttributes)
                        ReDim Preserve SignalAttributes(1 To Idx)
                    Else
'Idx(1) is always created
                        If Idx > 1 Then
'Signals must be created in ascending order
MsgBox "Duplicated Signal(" & Idx & ") detected", vbCritical, "LoadProfile"
                            Section = ""
                            GoTo Skip_line   'Get next line
                        End If
                    End If
'Load a null picture so that we can test if image =0
'if no picture has been loaded
'                    Set SignalAttributes(Idx).Image = LoadPicture("")
'Default is None
                    SignalAttributes(Idx).Controller = -1
'                    SignalAttributes(Idx).Class = -1
'Create a timer for each Signal (even if we dont use it)
                    Load frmMain.SignalTimer(Idx)
'Create the Command(idx) if it doesn't exist
'and CommandsExists
                    If Not CommandExists(Idx) Then
                        Load frmMain.Commands(Idx)
                        If UBound(StaticCommands) < Idx Then
                            ReDim Preserve StaticCommands(Idx)
                            'created - false so dont reposition
                        End If
                        frmMain.Commands(Idx).Visible = True
'Loads it disabled (not sure why)
                        frmMain.Commands(Idx).Enabled = True
                    End If
'Create the Image Control if it doesnt exist
                Else
                    MsgBox "Section " & Section & " has no Index", vbCritical, "LoadProfile"
                    Section = ""
                End If
            Case Else
                MsgBox "Section " & Section & " not Defined", vbCritical, "LoadProfile"
                Section = ""
            End Select
'CLOSE
        Case Is = "Close"
            If Section = "" Then
MsgBox "Section " & CleanSection & " not open", vbExclamation, "LoadProfile"
                GoTo Skip_line
            End If
            Select Case Section
            Case Is = "Profile"
            Case Is = "Class"
                Call LoadClassEvents(ClassStartElapsedTime / Multiplier)
            Case Is = "Template"
                Template = ""
            Case Is = "Controller"
'Stop
                Cidx = 0    'End of this Controller Default
            Case Is = "Signal"
'We have to so this at the end of the section because if CommandVisible has been changed
'we do not want to position it
                If StaticCommands(Idx) = False Then
                    Call frmMain.PositionCommand(Idx)
                End If
'Set command button caption to same as flag
                frmMain.Commands(Idx).Caption = SignalAttributes(Idx).Name
                Idx = 0       'End of this signal
            Case Is = "Event"
                Eidx = EventClose(Eidx)
'Must close the signal index as well
                Sidx = -1
            Case Else
            End Select
            Section = ""
            Idx = 0
            CleanSection = ""
'UPDATE
        Case Is = "Update"
            If Section = "" Then
MsgBox "Line Outside section" & vbCrLf & nextline & vbCrLf, vbExclamation, "LoadProfile"
            GoTo Skip_line       'We should have a section defined
            End If
            ReDim arry1(0)
            If UBound(arry) > 0 Then
                arry1 = Split(arry(1), ",")
            End If
            Select Case Section
            Case Is = "Profile"
                Select Case arry(0)
                Case Is = "Name"
 'Now use the file name thas is displayed in the Combo box
 '                           frmMain.Caption = App.EXEName & " [" & App.Major & "." & App.Minor & "." _
 '                           & App.Revision & "] " & arry(1)
                Case Is = "Version"
 'This is the version of the .ini file
                Case Is = "GroupDefault"
                    For i = 1 To UBound(GroupDefaults)
                        If GroupDefaults(i).Group = arry1(0) Then
                            Exit For
                        End If
                    Next i
                    If i > UBound(GroupDefaults) Then
                        ReDim Preserve GroupDefaults(i)
                    End If
                    GroupDefaults(i).Group = arry1(0)
                    For j = 1 To UBound(arry1)
                        Select Case arry1(j)
                        Case Is = "LastCol"
                            GroupDefaults(i).FixedCol = ColCount
                            ColCountFree = ColCount - 1
                        Case Is = "LastCol-1"
                            GroupDefaults(i).FixedCol = ColCount - 1
                            ColCountFree = ColCount - 2
                        Case Is = "Row1"
                            GroupDefaults(i).FixedRow = 1
                        Case Is = "Row2"
                            GroupDefaults(i).FixedRow = 2
                        Case Is = "Row3"
                            GroupDefaults(i).FixedRow = 3
                        Case Is = "Row4"
                            GroupDefaults(i).FixedRow = 4
                        Case Is = "Queue"
                            GroupDefaults(i).Queue = True
                        Case Else
                            MsgBox "Invalid " & arry1(j) & " in Profile Section " & Section
                        End Select
                    Next j
                Case Is = "Multiplier"
                    Multiplier = CLng(arry(1))
                    If Multiplier < 1 Then Multiplier = 1
                Case Is = "RecallControl"
                    RecallControl = AtoBool(arry(1))
                Case Is = "ButtonControl"
                    ButtonControl = AtoBool(arry(1))
                Case Is = "ButtonEvents"
                    ButtonEvents = AtoBool(arry(1))
                Case Is = "ClassSilenceControl"
                    ClassSilenceControl = AtoBool(arry(1))
                Case Is = "SoundOnAllFinishers"
                    SoundOnAllFinishers = AtoBool(arry(1))
                Case Is = "SkipClassOnRecall"
                    SkipClassOnRecall = AtoBool(arry(1))
                Case Else
                    MsgBox "Invalid " & arry(0) & " in Profile Section " & Section
                End Select
            Case Is = "Class"
'Stop
                Select Case arry(0)
                Case Is = "ElapsedTime"
                    ClassStartElapsedTime = arry(1)
                Case Else
                    MsgBox "Invalid " & arry(0) & " in Class Section " & Section
                End Select
            Case Is = "Template"
                Select Case Template
                Case Is = "Recall"
                    ReDim Preserve RecallTemplate(UBound(RecallTemplate) + 1)
                    Select Case arry(0)
                    Case Is = "Event", "/Event"
'Re-insert the [] which have been cleaned off, so LaosRecall will
'Identify the Open & Close
                        RecallTemplate(UBound(RecallTemplate)) = _
                        "[" & CleanLine & "]"
                    Case Else
                        RecallTemplate(UBound(RecallTemplate)) = CleanLine
                    End Select
                Case Is = "Class"
                    ReDim Preserve ClassTemplate(UBound(ClassTemplate) + 1)
                    Select Case arry(0)
                    Case Is = "Event", "/Event"
'Re-insert the [] which have been cleaned off, so LoadRecall will
'Identify the Open & Close
                        ClassTemplate(UBound(ClassTemplate)) = _
                        "[" & CleanLine & "]"
                    Case Else
                        ClassTemplate(UBound(ClassTemplate)) = CleanLine
                    End Select
                End Select
            Case Is = "Controller"
                Select Case arry(0)
                Case Is = "Name"
                    Controllers(Cidx).Name = arry(1)
                Case Is = "IpAddress"
                    Controllers(Cidx).IpAddress = arry(1)
                Case Is = "On"
                    Controllers(Cidx).On = arry(1)
                Case Is = "Off"
                    Controllers(Cidx).Off = arry(1)
                Case Is = "Connection"
                    Controllers(Cidx).Connection = arry(1)
                Case Is = "Sound"
                    Controllers(Cidx).Sound = arry(1)
                    If FileExists(CommonAppData & "Arundale\RacingSignals\Sounds\" & arry(1)) Then
                        SoundFilePath = CommonAppData & "Arundale\RacingSignals\Sounds\"
                        Call OpenWav(arry(1))
                    Else
MsgBox "Sound File " & arry1(0) & " doesnt exist"
                    End If
                Case Else
                    MsgBox "Invalid " & arry(0) & " in Controller Section " & Section
                End Select
            Case Is = "Signal"
'Check again we've got an index
                If Idx = 0 Then
MsgBox "No index " & arry(0) & " in Profile Section " & Section
                    GoTo Skip_line
                End If
                Select Case arry(0)
                Case Is = "Type"
                    SignalAttributes(Idx).Type = arry(1)
                Case Is = "Name"
                    SignalAttributes(Idx).Name = arry(1)
                Case Is = "TTL"
                    SignalAttributes(Idx).TTL = arry(1)
'Set TTD as same as TTL (On and Off for same time) - Is a Default
                    SignalAttributes(Idx).TTD = arry(1)
'Set timer interval immediately before it is enabled
'                                frmMain.SignalTimer(Idx).Interval = arry(1)
                Case Is = "TTD"
                    SignalAttributes(Idx).TTD = arry(1)
                Case Is = "Cycles"
'                               Select Case SignalAttributes(Idx).Type
'Type must have been set in .ini before Cycles
'Not used now (I think)                                Case Is = "Recall", "Postpone"
'                                    SignalAttributes(Idx).CyclesRequired = arry(1) / Multiplier
'                                Case Else
                    SignalAttributes(Idx).CyclesRequired = arry(1)
'                                End Select
                Case Is = "UpLink", "DownLink"
                    MyLink.Type = arry(0)
                    MyLink.Flag = arry1(0)
                    If UBound(arry1) > 0 Then
                        MyLink.Raise = AtoBool(arry1(1))
'Create the Links(Next Link Index)
                        Call CreateLink(Idx, MyLink)
                    Else
MsgBox "Flag (" & Idx & "), " & arry(0) & " requires True or False"
                    End If
                Case Is = "Controller"
                    SignalAttributes(Idx).Controller = arry(1)
'Flag attributes
                Case Is = "Flag"
'Put in Image in the Signal attributes
                    If FileExists(SignalImageFilePath & arry1(0) & ".gif") Then
                        Set SignalAttributes(Idx).Image = LoadPicture(SignalImageFilePath & arry1(0) & ".gif")
                    Else
MsgBox "Flag " & arry1(0) & " doesnt exist"
                    End If
#If False Then
                Case Is = "FunctionKey"
'Only Function Keys are valid (at the moment)
                    If Left$(arry(1), 1) = "F" Then
                        i = 111 + Mid$(arry(1), 2)
                    Else
                        i = 0
                    End If
                    If i > 0 And i < 128 Then
'Set Key Function to State.Function that applies to this Key
                        Select Case SignalAttributes(Idx).Name
                        Case Is = "Postpone"
                            Keys(i).Function = 1
                        Case Is = "Recall"
                            Keys(i).Function = 2
                        Case Is = "General Recall"
                            Keys(i).Function = 3
                        Case Is = "Finish"
                            Keys(i).Function = 4
                        Case Else
MsgBox "KeyCode " & arry(1) & " cannot be defined"
                        End Select
                        Keys(i).KeyName = arry(1)
                        Keys(i).Code = i
                        SignalAttributes(Idx).Key = i
                    Else
MsgBox "KeyCode " & arry(1) & " cannot be defined"
                    End If
'not used                    SignalAttributes(Idx).Key = Keys(i).Code
#End If
                Case Is = "Group"
                    SignalAttributes(Idx).Group = arry(1)
                    For i = 1 To UBound(GroupDefaults)
                        If GroupDefaults(i).Group = arry(1) Then
                            Exit For
                        End If
                    Next i
                    If i <= UBound(GroupDefaults) Then
                        SignalAttributes(Idx).Flag.FixedCol = GroupDefaults(i).FixedCol
                        SignalAttributes(Idx).Flag.FixedRow = GroupDefaults(i).FixedRow
                        SignalAttributes(Idx).Flag.Queue = GroupDefaults(i).Queue
                    End If
                Case Is = "Row"
                    SignalAttributes(Idx).Flag.FixedRow = arry(1)
                        
'Raise on load Testing only, can only do when This Signal is closed, as we do not know the position
                Case Is = "Raised"
 'Initially display the flag for debugging the Position
                    If AtoBool(arry(1)) = True Then
                        Call frmMain.RaiseRequest(Idx)
                    End If
'CommandAttributes
                Case Is = "CommandVisible"
                    frmMain.Commands(Idx).Visible = AtoBool(arry(1))
'CommandFrame not currently used
                Case Is = "CommandFrame"
'                                    Set MyFrame = NametoFrame(arry(1))  'an Object
                    Select Case arry(1)
                    Case Is = "Postponement", "Horn"
                        Set frmMain.Commands(Idx).Container = MyFrame
                        frmMain.Commands(Idx).Top = 0
                        frmMain.Commands(Idx).Left = 0
                        frmMain.Commands(Idx).Width = 1700
'Position in middle of frame at the bottom
                        frmMain.Commands(Idx).Move _
                        (MyFrame.Width _
                        - frmMain.Commands(Idx).Width) / 2 _
                        , MyFrame.Height _
                        - frmMain.Commands(Idx).Height - 100
                        MyFont.Name = "Verdana"
                        MyFont.Size = 14
                        MyFont.Bold = True
                        Set frmMain.Commands(Idx).Font = MyFont
                    Case Else
MsgBox "Command Frame " & arry(1) & " Container doesnt exist"

                    End Select
'frmMain.Commands(Idx).Visible = True
'Stop
                Case Else
MsgBox "Invalid " & arry(0) & " in Profile Section " & Section
                End Select  'of [Signal]
            Case Is = "Event"
                Call EventUpdate(Eidx, CleanLine)
            Case Else
MsgBox "Line Outside section" & vbCrLf & nextline & vbCrLf, vbExclamation, "LoadProfile"
            End Select
        
        Case Else
MsgBox "Invalid LineType (" & nextline & ")", vbCritical, "LoadProfile"
            GoTo Skip_line
        End Select

Skip_line:
'Call CleanProfileLine(NextLine)
    Loop
    Close #ch
WriteLog "Profile Closed"

    Kill DecryptedFileName
WriteLog "Profile Killed"
'    Call frmEvents.ListEvents
'Check Command Button Signals have been defined
    Call CommandIdx("Postpone")
    Call CommandIdx("Horn Short")
    Call CommandIdx("Recall")
    Call CommandIdx("General Recall")
    Call CommandIdx("Finish")
    RecallSignalIdx = SignalFromName("Recall Class")
    If RecallSignalIdx = 0 Then
MsgBox "Recall Class Signal not defined", vbCritical, "LoadProfile"
    End If
'Silence Class Flags raised at same time as a Class Flag is Lowered
    If ClassSilenceControl Then Call ClassSilence
'Load Recalls for all Classes into evts
    If RecallControl Then Call ClassRecalls
        
'Clear the Splash display (after 3 secs) - Not fully loaded until Splash screen has
'been cleared
    frmMain.ClearFlagsTimer.Enabled = True
    
'    frmMain.cmdEvents.Enabled = True
'    Loading = False
    frmMain.RaceTimer.Enabled = True
WriteLog "RaceTimer Enabled"
'temp stop    frmMain.RaceTimer.Enabled = True

Exit Function

LoadProfile_err:
    Select Case Err.Number
    End Select
    WriteLog "LoadProfile Error " & Str(Err.Number) & " " & Err.Description
    MsgBox "LoadProfile Error " & Str(Err.Number) & " " & Err.Description, vbCritical, "LoadProfile"
End Function
    
'Returns "Open","Close","Update","Skip"
'And cleans inbuf
Private Function CleanProfileLine(ByRef Inbuf As String) As String
Dim i As Long
Dim j As Long
Dim CleanLine As String
Dim CleanSection As String

'Strip Comments
        i = InStr(1, Inbuf, "'")
        If i > 0 Then
            CleanLine = Left$(Inbuf, i - 1)
        Else
            CleanLine = Inbuf
        End If
'Remove leading & trailing whitespace
        CleanLine = Replace(CleanLine, vbTab, "")
        CleanLine = Trim(CleanLine)
        If CleanLine = "" Then GoTo Skip_line
'Debug.Print CleanLine
        i = InStr(1, CleanLine, "[")
        If (i > 0) Then
'This is Open or Close Section
            j = InStrRev(CleanLine, "]")
            If j < i Then
                MsgBox "Parse error:" & vbCrLf & Inbuf, vbCritical, "LoadProfile"
                GoTo Skip_line   'Skip this line (no closing bracket)
            End If
            CleanSection = Mid$(CleanLine, i + 1, j - i - 1)
            If Len(CleanSection) = 0 Then   'Blank section
                GoTo Skip_line
            End If
'If Cleaned up Section not blank
            Inbuf = CleanSection
            If Mid$(CleanLine, 2, 1) <> "/" Then
'Open section (Sets up Section & SectionIndex to be used by next Input Lines
                CleanProfileLine = "Open"
            Else
                CleanProfileLine = "Close"
            End If
    Else
        Inbuf = CleanLine
        CleanProfileLine = "Update"
    End If
Finish:
Exit Function

Skip_line:
    CleanProfileLine = "Skip"
    GoTo Finish
End Function

'Returns Eidx, Check Eidx ensures it is not already open
Private Function EventOpen(ByVal ElapsedTime As Long) As Long
    EventOpen = FreeEidx(ElapsedTime)
End Function

'Eidx is dealt with like Ch on File Open,Read,Close
'Must be by Ref to Update Eidx in ModMain
Private Function EventClose(ByVal Eidx As Long) As Long
    If Eidx = -9999 Then
MsgBox "Event not open", vbCritical, "EventClose"
        Exit Function
    End If
    EventClose = -9999
End Function

'Only Called while profile is being loaded
'by LoadProfile,LoadRecallEvents,LoadClassEvents,LoadFinishEvents
Private Function EventUpdate(ByVal Eidx As Long, ByVal Inbuf As String)
Dim arry() As String
Dim arry1() As String
Dim Bidx As Long    'OK here because all args passed on same line
Dim Fcidx As Long

'Split the line arry Name=Value1,Value2
    If Eidx = -9999 Then
MsgBox "Event not open", vbCritical, "EventUpdate"
        Exit Function
    End If
    If CleanProfileLine(Inbuf) <> "Update" Then
'Cleans Inbuf
'Stop
        Exit Function
    End If
    arry = Split(Inbuf, "=")
    ReDim arry1(0)
    If UBound(arry) > 0 Then
        arry1 = Split(arry(1), ",")
    End If
        Select Case arry(0)
        Case Is = "Signal"
'get a new index
'If arry(1) = "Class 3" Then Stop
            Sidx = FreeSidx(Eidx, SignalFromName(arry(1)))
            Call PutSignalEvent(Eidx, Sidx)
        Case Is = "Button"
            Bidx = FreeBidx(Eidx, SignalFromName(arry1(0)))
            Call PutButtonEvent(Eidx, Bidx, arry1(1))   'Enabled
        Case Is = "Message"
'Make the event message the first one for this time.
'This Should be the class start
            If Evts(Eidx).Message = "" Then
                Call PutEvent(Eidx, arry(1))
            End If
        Case Is = "Focus"
            Call PutEvent(Eidx, , arry1(0))
        Case Is = "Raised"
'Needs Sidx passing, must have been defined with [Signal=]
            Call PutSignalEvent(Eidx, Sidx, arry(1))
        Case Is = "Silent"
'Needs Sidx passing
            Call PutSignalEvent(Eidx, Sidx, , arry(1))
        Case Is = "Recalls"
            Bidx = FreeBidx(Eidx, frmMain.CommandFromCaption("Recall"))
            Call PutButtonEvent(Eidx, Bidx, arry(1))   'Enabled
            Bidx = FreeBidx(Eidx, frmMain.CommandFromCaption("General Recall"))
            Call PutButtonEvent(Eidx, Bidx, arry(1))   'Enabled
'Must do after Button has been enables - to set the Focus
            If AtoBool(arry(1)) = True Then
                Call PutEvent(Eidx, "Enable Recalls", "Recall")
            Else
                Call PutEvent(Eidx, "Disable Recalls")
            End If
        Case Is = "FunctionCall"
            Select Case arry1(0)
            Case Is = "QueryRecallTimeout", "RecallTimeout", "LoadPostpone" _
            , "UnloadPostpone", "LoadStart"
                Fcidx = FreeFcidx(Eidx, arry1(0))
                Call PutFunctionCallEvent(Eidx, Fcidx, arry(1))   'Name
            Case Else
             MsgBox "Invalid Function Call-" & arry(0), vbCritical, "EventUpdate"
            End Select
        Case Else
 MsgBox "Invalid Event-" & arry(0), vbCritical, "EventUpdate"
        End Select  'of [Signal]

End Function

Private Function LoadRecallEvents(ByVal ElapsedTime As Long)
Dim i As Long
Dim nextline As String
Dim arry() As String
Dim EventOffset As Long
Dim LineType As String
Dim RecallEidx As Long    'Only for the recall
Dim kb As String
    
    RecallEidx = -9999
    For i = 0 To UBound(RecallTemplate)
        nextline = RecallTemplate(i)
        If nextline = "" Then GoTo Skip_line
        arry = Split(nextline, "=")
        Select Case arry(0)
        Case Is = "EventOffset"
            EventOffset = arry(1) / Multiplier
        Case Else
            LineType = CleanProfileLine(nextline)   'NextLine is cleaned
'Helpds debugging
            nextline = Replace(nextline, "<ElapsedTime>", ElapsedTime)
            nextline = Replace(nextline, "<EventOffset>", EventOffset)
            nextline = Replace(nextline, "<ClassName>", EventClassName)
Debug.Print "R>" & nextline
'If Left$(NextLine, 6) = "Signal" Then Stop
            Select Case LineType
            Case Is = "Open"
               If RecallEidx <> -9999 Then
MsgBox "Event not Closed", vbCritical, "EventOpen"
                    Exit Function
                Else
                    RecallEidx = EventOpen(ElapsedTime + EventOffset)
                End If
            Case Is = "Close"
                RecallEidx = EventClose(RecallEidx)
            Case Is = "Update"
'If ElapsedTime + ElapsedOffset = 240 Then Stop
                Call EventUpdate(RecallEidx, nextline)
'frmEvents.ListEvents
'frmEvents.WindowState = vbNormal  'Scale will be 0 in VBE (window is minimized)
'frmEvents.Refresh
'frmEvents.Visible = True
'kb = frmEvents.ScaleHeight
'Stop
            Case Is = "Skip"
            Case Else
MsgBox "Invalid LineType (" & nextline & ")", vbCritical, "LoadRecallEvents"
            End Select
'            Call ParseProfile(NextLine)
        End Select
Skip_line:
    Next i

'frmEvents.ListEvents
End Function

Private Function LoadClassEvents(ByVal ElapsedTime As Long)
Dim i As Long
Dim nextline As String
Dim arry() As String
Dim EventOffset As Long
Dim LineType As String
Dim EidxTime As Long    'Only for the Class
Dim kb As String

    EidxTime = -9999   'Assume no event set up (must not be a valid elapsed time)
                        'Because the OpenEidx returns the Elapsed time
    For i = 0 To UBound(ClassTemplate)
        nextline = ClassTemplate(i)
        arry = Split(nextline, "=")
        Select Case arry(0)
        Case Is = "EventOffset"
            EventOffset = arry(1) / Multiplier
        Case Else
            LineType = CleanProfileLine(nextline)   'NextLine is cleaned
'Helpds debugging
            nextline = Replace(nextline, "<ElapsedTime>", ElapsedTime)
            nextline = Replace(nextline, "<EventOffset>", EventOffset)
            nextline = Replace(nextline, "<ClassName>", EventClassName)
Debug.Print "R>" & nextline
'If Left$(NextLine, 6) = "Signal" Then Stop
            Select Case LineType
            Case Is = "Open"
               If EidxTime <> -9999 Then
MsgBox "Event not Closed", vbCritical, "EventOpen"
                    Exit Function
                Else
                    EidxTime = EventOpen((ElapsedTime + EventOffset))
                End If
            Case Is = "Close"
                EidxTime = EventClose(EidxTime)
            Case Is = "Update"
'If ElapsedTime + ElapsedOffset = 240 Then Stop
                Call EventUpdate(EidxTime, nextline)
            Case Is = "Skip"
            Case Else
MsgBox "Invalid LineType (" & nextline & ")", vbCritical, "LoadClassEvents"
            End Select
'            Call ParseProfile(NextLine)
        End Select
    Next i
'frmEvents.ListEvents
End Function

'Called when LoadProfile is finished
Private Function LoadStartEvents()
Dim Eidx As Long
        
    Eidx = EventOpen(Evts(0).ElapsedTime)
    Evts(Eidx).Message = "Start Sequence"
    Call EventClose(Eidx)
    
End Function

Private Function LoadFinishEvents()
Dim Eidx As Long
            
'    EventClassName = "Finish"
'    Eidx = UBound(Evts)
    
    Eidx = EventOpen(Evts(UBound(Evts)).ElapsedTime + 1)
'This is the very latest you can postpone
'you can change a general recall to postpone

'    Call EventUpdate(Eidx, "Signal=Postpone")
'    Call EventUpdate(Eidx, "Raised=False")
    Call EventUpdate(Eidx, "Button=Postpone,False")
    
    Evts(Eidx).Message = "Finish Enabled"
    Call EventUpdate(Eidx, "Button=Horn Short,True")
'Dont think this should be required
'    Call EventUpdate(Eidx, "Signal=White Fl")
'    Call EventUpdate(Eidx, "Raised=False")
    Call EventUpdate(Eidx, "Focus=Finish")
    Call EventClose(Eidx)
End Function

Public Function CommandExists(Idx As Long) As Boolean
Dim MyCommand As CommandButton
    For Each MyCommand In frmMain.Commands
        If MyCommand.Index = Idx Then
            CommandExists = True
            Exit Function
        End If
    Next MyCommand
End Function

Public Function AtoBool(kb As String) As Boolean
    If kb = "True" Then AtoBool = True
End Function

Public Function CommandIdx(CommandName As String) As Long
Dim kb As String
Dim MyCommand As CommandButton
    
    For Each MyCommand In frmMain.Commands
        If MyCommand.Caption = CommandName Then
            CommandIdx = MyCommand.Index
            Exit Function
        End If
    Next MyCommand
MsgBox "Command Button " & CommandName & " not found", vbExclamation, "CommandIdx"
End Function

Public Function NameFromFullPath(FullPath As String, Optional Delimiter As String, Optional RemoveRollover As Boolean) As String
'Input: Name/Full Path of a file
'Returns: Name of file

    Dim sPath As String
    Dim sList() As String
    Dim sAns As String
    Dim iArrayLen As Integer
    Dim i As Integer
    Dim j As Integer
    Dim kb As String
    
'MsgBox FullPath
    If Delimiter = "" Then Delimiter = "\"
    If Len(FullPath) = 0 Then Exit Function
    sList = Split(FullPath, Delimiter)
    iArrayLen = UBound(sList)
    sAns = IIf(iArrayLen = 0, "", sList(iArrayLen))
'only filename
'MsgBox FullPath
    If sAns = "" And iArrayLen = 0 Then sAns = FullPath
    If RemoveRollover And sAns <> "" Then
        j = InStr(sAns, ".") 'get the first dot
        If j = 0 Then j = Len(sAns) 'no dot so all the string
        i = InStrRev(Left$(sAns, j), "_")
        If j = i + 9 Then 'msu be _yyyymmdd.
            If IsNumeric(Mid$(sAns, i + 1, 8)) Then
                sAns = Replace(sAns, Mid$(sAns, i, 9), "")
            End If
        End If
    End If
    
    NameFromFullPath = sAns

End Function


' Return True if a file exists
Public Function FileExists(FileName As String) As Boolean
    FileExists = False
'MsgBox FileName & ":" & GetAttr(FileName)
    On Error GoTo ErrorHandler
    If NameFromFullPath(FileName) <> "" Then  'directory
'does file exists
        If (GetAttr(FileName) And vbNormal) = vbNormal Then FileExists = True
    End If
ErrorHandler:
    ' if an error occurs, this function returns False
'MsgBox FileName & vbCrLf & FileExists
End Function

Public Function CreateLink(ByRef Idx As Long, Link As defLink)
    With SignalAttributes(Idx)
        If IsLinksInitialised(.Links) = False Then
            ReDim .Links(0)
        Else
            ReDim Preserve .Links(UBound(.Links) + 1)
        End If
        .Links(UBound(.Links)) = Link
    End With
End Function

Public Function IsLinksInitialised(ByRef arr() As defLink) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsLinksInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsEvtsInitialised(ByRef arr() As defEvt) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsEvtsInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsSignalsInitialised(ByRef arr() As defSignalEvt) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsSignalsInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsButtonsInitialised(ByRef arr() As defButtonEvt) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsButtonsInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsFunctionCallsInitialised(ByRef arr() As defFunctionCallEvt) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsFunctionCallsInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsKeysInitialised(ByRef arr() As defKey) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsKeysInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

Public Function IsClassesInitialised(ByRef arr() As defClass) As Boolean
Dim Temp As Long
    On Error GoTo errHandler 'Raise error if directory doesnot exist
    Temp = UBound(arr)
    If Temp > -1 Then IsClassesInitialised = True 'UBound is greater then -1
Exit Function
errHandler:
End Function

'Returns the index from the Signal name,
'Only used by LoadProfile so that the .ini file can refer to it by name which makes
'Setting up the initialisation file easier.
'Return 0 if not found
Public Function SignalFromName(ByVal Name As String) As Long
Dim Idx As Long

    For Idx = 1 To UBound(SignalAttributes)
        With SignalAttributes(Idx)
            If .Name = Name Then
                SignalFromName = Idx
                Exit For
            End If
        End With
    Next Idx
End Function

'Return Eidx of first event at this time -1 = not found
Public Function EventToEidx(ByVal ElapsedTime, ByVal Idx As Long) As Long
Dim Eidx As Long

    EventToEidx = -1
    If IsEvtsInitialised(Evts) Then
        For Eidx = 0 To UBound(Evts)
            If Evts(Eidx).ElapsedTime = ElapsedTime And Evts(Eidx).Signal = Idx Then
                EventToEidx = Eidx
                Exit Function
            End If
        Next Eidx
    End If
End Function

'only Called by EventUpdate
Public Function PutEvent(ByVal Eidx As Long, Optional Message As String, Optional FocusName As String)
    If Message <> "" Then
        Evts(Eidx).Message = Evts(Eidx).Message & Message
    End If
    If FocusName <> "" Then
        Evts(Eidx).Focus = frmMain.CommandFromCaption(FocusName)
    End If

End Function

Public Function PutButtonEvent(ByVal Eidx As Long, ByVal Bidx As Long, Optional Enabled As String)
    If Enabled <> "" Then
        Evts(Eidx).Buttons(Bidx).Enabled = Enabled
    End If
End Function

Public Function PutFunctionCallEvent(ByVal Eidx As Long, ByVal Fcidx As Long, Optional Name As String)
    If Name <> "" Then
        Evts(Eidx).FunctionCalls(Fcidx).Name = Name
    End If
End Function

'Signal must have been defined
Public Function PutSignalEvent(ByVal Eidx As Long, ByVal Sidx As Long, Optional Raise As String, Optional Silent As String)
    If Raise <> "" Then
        Evts(Eidx).Signals(Sidx).Raise = Raise
    End If
    If Silent <> "" Then
        Evts(Eidx).Signals(Sidx).Silent = Silent
    End If
End Function

'Returns EidxTime
Public Function FreeEidx(ByVal ElapsedTime As Long) As Long
Dim Eidx As Long
Dim i As Long
Dim j As Long
Dim BlankEvt As defEvt
Dim Idx As Long

    Idx = SignalFromName(EventClassName)
    If Not IsEvtsInitialised(Evts) Then
        ReDim Evts(0)
        Eidx = 0
        Evts(Eidx).Signal = Idx   'only when first created
        Evts(Eidx).Class = SignalAttributes(Idx).Class
    Else
'See if we already have this event time and Class set up
        Eidx = EventToEidx(ElapsedTime, Idx)
        If Eidx < 0 Then
'Event for this time is not set up is not set up
'Is this a later event than the latest one
            If ElapsedTime > Evts(UBound(Evts)).ElapsedTime Then
                Eidx = UBound(Evts) + 1
                ReDim Preserve Evts(Eidx)
                Evts(Eidx).Signal = Idx   'only when first created
                Evts(Eidx).Class = SignalAttributes(Idx).Class
            Else
'Earlier than latest event, shift events to create a blank event at the required time
'Get the first event that wants shifting up
                For i = 0 To UBound(Evts)
                    If Evts(i).ElapsedTime > ElapsedTime Then Exit For
                Next i
'Now Create a new Blank record on the top
                ReDim Preserve Evts(UBound(Evts) + 1)
'Work Sown the array moving each one up
                For j = UBound(Evts) To i + 1 Step -1
                    Evts(j) = Evts(j - 1)
                Next j
'J is 1 less on exit
                Evts(j) = BlankEvt
                Eidx = j
                Evts(Eidx).Signal = Idx   'only when first created
                Evts(Eidx).Class = SignalAttributes(Idx).Class
            End If
        End If
    End If
    Evts(Eidx).ElapsedTime = ElapsedTime
    Evts(Eidx).Focus = -1   'Default (0=Commands(0))
    FreeEidx = Eidx
'frmEvents.ListEvents
End Function

'returns -1 if Idx is invalid (0 is valid)
Public Function FreeBidx(ByVal Eidx As Long, ByVal Idx As Long) As Long
Dim Bidx As Long

    If Idx < 0 Then
MsgBox "Invalid Button Index in FreeBidx"
        FreeBidx = -1
        Exit Function
    End If
    
    If Not IsButtonsInitialised(Evts(Eidx).Buttons) Then
        ReDim Evts(Eidx).Buttons(0)
        Bidx = 0
        Evts(Eidx).Buttons(Bidx).Button = Idx
    Else
        Bidx = IsBidx(Eidx, Idx)
        If Bidx = 0 Then
            Bidx = UBound(Evts(Eidx).Buttons) + 1
            ReDim Preserve Evts(Eidx).Buttons(Bidx)
            Evts(Eidx).Buttons(Bidx).Button = Idx
        End If
    End If
'    Evts(Eidx).Buttons(Bidx).signal = SignalFromName(EventClassName)
    FreeBidx = Bidx
End Function

'returns -1 if Idx is invalid (0 is valid)
Public Function FreeFcidx(ByVal Eidx As Long, ByVal FcName As String) As Long
Dim Fcidx As Long

    If FcName = "" Then
MsgBox "Invalid FunctionCalls Index in FreeFcidx"
        FreeFcidx = -1
        Exit Function
    End If
    
    If Not IsFunctionCallsInitialised(Evts(Eidx).FunctionCalls) Then
        ReDim Evts(Eidx).FunctionCalls(0)
        Fcidx = 0
        Evts(Eidx).FunctionCalls(Fcidx).Name = FcName
    Else
        Fcidx = IsFcidx(Eidx, FcName)
        If Fcidx = 0 Then
            Fcidx = UBound(Evts(Eidx).FunctionCalls) + 1
            ReDim Preserve Evts(Eidx).FunctionCalls(Fcidx)
            Evts(Eidx).FunctionCalls(Fcidx).Index = Fcidx
        End If
    End If
'    Evts(Eidx).Buttons(Stidx).signal = SignalFromName(EventClassName)
    FreeFcidx = Fcidx
End Function

'Returns Bidx if an Idx has been set up for this Time
Public Function IsBidx(ByVal Eidx As Long, ByVal Idx As Long) As Long
Dim i As Long
    For i = 0 To UBound(Evts(Eidx).Buttons)
        If Evts(Eidx).Buttons(i).Button = Idx Then
            IsBidx = i
            Exit Function
        End If
    Next i
End Function

'Returns Fcidx if this FunctionCall has been set up for this Time
Public Function IsFcidx(ByVal Eidx As Long, ByVal Name As String) As Long
Dim i As Long
    For i = 0 To UBound(Evts(Eidx).FunctionCalls)
        If Evts(Eidx).FunctionCalls(i).Name = Name Then
            IsFcidx = i
            Exit Function
        End If
    Next i
End Function

'Returns Sidx
Public Function FreeSidx(ByVal Eidx As Long, ByVal Idx As Long) As Long
Dim Sidx As Long

    If Idx < 1 Then
MsgBox "Invalid Signal Index in FreeSidx"
        FreeSidx = -1
        Exit Function
    End If
    
    If Not IsSignalsInitialised(Evts(Eidx).Signals) Then
        ReDim Evts(Eidx).Signals(0)
        Sidx = 0
        Evts(Eidx).Signals(Sidx).Signal = Idx
    Else
        Sidx = IsSidx(Eidx, Idx)
        If Sidx = 0 Then
            Sidx = UBound(Evts(Eidx).Signals) + 1
            ReDim Preserve Evts(Eidx).Signals(Sidx)
            Evts(Eidx).Signals(Sidx).Signal = Idx
        End If
    End If
'Debug.Print EventClassName
'Set up the signal index
'    Evts(Eidx).Signals(Sidx).signal = SignalFromName(EventClassName)
'Stop
    FreeSidx = Sidx
End Function

'Returns Sidx if an Idx has been set up for this Time
Public Function IsSidx(ByVal Eidx As Long, ByVal Idx As Long) As Long
Dim i As Long
    For i = 0 To UBound(Evts(Eidx).Signals)
        If Evts(Eidx).Signals(i).Signal = Idx Then
            IsSidx = i
            Exit Function
        End If
    Next i
End Function

'
Private Function ClassRecalls()
Dim Eidx As Long
Dim Sidx As Long
Dim Csidx As Long
Dim Fcidx As Long
Dim i As Long

'Create start times in Classes
'Must be done in 1 pass because evts will be inserted before the
'current event so Evts & Eidx would change between each pass
    
    For Eidx = 0 To UBound(Evts)
        If IsSignalsInitialised(Evts(Eidx).Signals) Then
            For Sidx = 0 To UBound(Evts(Eidx).Signals)
                If SignalAttributes(Evts(Eidx).Signals(Sidx).Signal).Group = "Class" Then
                    For Csidx = 1 To UBound(Classes)
                        If Classes(Csidx).Name = SignalAttributes(Evts(Eidx).Signals(Sidx).Signal).Name Then
                            Exit For
                        End If
                    Next Csidx
                    If Evts(Eidx).Signals(Sidx).Raise = "True" Then
                        Classes(Csidx).Signal = Evts(Eidx).Signals(Sidx).Signal
                        Classes(Csidx).Warning = Evts(Eidx).ElapsedTime
'                    Else
'                        Classes(Csidx).Start = Evts(Eidx).ElapsedTime
                    End If
                End If
            Next Sidx
        End If
        If IsFunctionCallsInitialised(Evts(Eidx).FunctionCalls) Then
            For Fcidx = 0 To UBound(Evts(Eidx).FunctionCalls)
                If Evts(Eidx).FunctionCalls(Fcidx).Name = "LoadStart" Then
                    Classes(Evts(Eidx).Class).start = Evts(Eidx).ElapsedTime
                End If
            Next Fcidx
        End If
    Next Eidx
     
    EventClassName = Classes(1).Name
    Call LoadStartEvents
    For Csidx = 1 To UBound(Classes)
'Set the EventClass name that will be associated with the Signal & button events
        EventClassName = Classes(Csidx).Name
        Call LoadRecallEvents(Classes(Csidx).start)
    Next Csidx
    EventClassName = Classes(UBound(Classes)).Name
    Call LoadFinishEvents
End Function
'SYC if we are raising the next Class flag at the same time as lowering
'the Start Class flag, we must silence the raised flag
'(ie the next class Warning)
Private Function ClassSilence()
Dim Eidx As Long
Dim Sidx As Long
Dim Silence As Boolean
Dim i As Long

    For Eidx = 0 To UBound(Evts)
        Silence = False
        If IsSignalsInitialised(Evts(Eidx).Signals) Then
            For Sidx = 0 To UBound(Evts(Eidx).Signals)
                If SignalAttributes(Evts(Eidx).Signals(Sidx).Signal).Group = "Class" Then
                    If Evts(Eidx).Signals(Sidx).Raise = "False" Then
                        Silence = True
                    Else
                        If Silence = True Then
                            Evts(Eidx).Signals(Sidx).Silent = True
                        End If
                    End If
                End If
            Next Sidx
        End If
    Next Eidx
End Function

Public Function aMins(ByVal Seconds As Long) As String
Dim kb As String
    If Seconds < 0 Then kb = "-"
    Seconds = Abs(Seconds)
    
    kb = kb & Format$(Seconds \ 60, "0")
    kb = kb & ":" & Format$(Seconds Mod 60, "00")
    aMins = kb
End Function

'http://www.vbforums.com/showthread.php?267061-*Resolved*-An-empty-UDT-array
Public Function UdtArrayExists() As Boolean
    If SafeArrayGetDim(Evts) > 0 Then
        UdtArrayExists = True
    End If
End Function


Public Function SetState_old(StateType As String, ReqState As Long, Optional FunctionClass As Long)
Dim i As Long
'Stop    'Should no longer be used
    Select Case StateType
    Case Is = "Program"
        State.Program = ReqState
        Select Case State.Program
        Case Is = 0             'No Profile
        Case Is = 1             'Loading Profile
            State.Sequence = 0
'no longer exists            State.FunctionClass = 0
            State.StartClass.Next = 0
            State.StartClass.Last = 0
            State.EventPause = 0
        Case Is = 2             'Profile Loaded Called by ClearFlagsTimer event
            State.Sequence = 1  'NotStarted
        Case Is = 3             'Start Time Set
'            State.FunctionClass = 1 'Class will be 0 when start time is reset
            State.Sequence = 2  'Postpone
'no longer exists            Keys(Functions(State.Sequence).Keyno).Class = 1
'Stop
            State.StartClass.Last = 0
            State.StartClass.Next = 1
'Must be done by calling SetState to force update of startTimes display
        Case Is = 4     'Start Sequence Commenced
'no longer exists            State.FunctionClass = 1 'Must be first class start
'no longer exists Keys(Functions(State.Sequence).Keyno).Class = 1
'Stop
        Case Is = 5     'Start Sequence Finished
        Case Else
            MsgBox "Undefined StateType " & ReqState, , "SetState"
    End Select
    Case Is = "Function"    'Change Function Key
        State.Sequence = ReqState
'        Keys(Functions(State.Function).Keyno).Function = ReqState
        Select Case State.Sequence
        Case Is = 0             'Disabled
        Case Is = 1             'Postpone"
'no longer exists Keys(Functions(State.Sequence).Keyno).Class = State.StartClass.Next
        Case Is = 2             'Recall
'no longer exists Keys(Functions(State.Sequence).Keyno).Class = State.StartClass.Last
        Case Is = 3             'General Recall
''no longer exists Keys(Functions(State.Sequence).Keyno).Class = State.StartClass.Last
        Case Is = 4             'Finish
        Case Else               'Undefined Function
            MsgBox "Undefined Function " & ReqState, , "SetState"
        End Select
    
    Case Is = "FunctionClass"
'Stop
'no longer exists        State.FunctionClass = ReqState
'no longer exists Keys(Functions(State.Function).Keyno).Class = ReqState
    Case Is = "ClassRestart"
        State.StartClass.Last = ReqState
        State.StartClass.Next = ReqState
        State.EventPause = -1
    Case Is = "LastStartClass"
'Set both Last and Next at the same time
'Stop
        If State.StartClass.Last <> ReqState Then
'Start changed
            State.StartClass.Last = ReqState
'Set NextStart
            Select Case ReqState
            Case Is = 0:    State.StartClass.Next = 1
            Case Is < UBound(Classes): State.StartClass.Next = ReqState + 1
            Case Is = UBound(Classes): State.StartClass.Next = 0
            Case Else
                MsgBox "Undefined NextClassStart", , "SetState"
            End Select
            Call frmMain.DisplayStartTimes
'            Keys(Functions(State.Function).Keyno).Class = State.startclass.Last
        End If
    Case Is = "NextEventTime"
    Case Is = "KeyState"
'no longer exists        Keys(Functions(State.Function).Keyno).Cancel = CBool(ReqState)
    Case Else
        MsgBox "Undefined StateType", , "SetState"
    End Select
'wont complile    Call frmMain.DisplayState
End Function

#If False Then
Public Function aGetState() As String
Dim kb As String
Dim SignalName As String

    Select Case State.Program
    Case Is = 0: kb = "Loading Forms"
    Case Is = 1: kb = "Loading Profile"
    Case Is = 2: kb = "Profile Loaded"
    Case Is = 3: kb = "Start Time Set"
    Case Is = 4: kb = "Start Sequence Commenced"
    Case Is = 5: kb = "Start Sequence Finished"
    Case Else: kb = "Undefined"
    End Select
    Select Case State.Function
    Case Is = 0: kb = kb & ",F=Disabled"
    Case Is = 1
        kb = kb & ",F=Postpone"
        If State.FunctionClass <> 0 Then
            kb = kb & "-" & Classes(State.FunctionClass).Name
        End If
    Case Is = 2
        kb = kb & ",F=Recall"
        If State.FunctionClass <> 0 Then
            kb = kb & "-" & Classes(State.FunctionClass).Name
        End If
    Case Is = 3
        kb = kb & ",F=General Recall"
        If State.FunctionClass <> 0 Then
            kb = kb & "-" & Classes(State.FunctionClass).Name
        End If
    Case Is = 4: kb = kb & ",F=Finish"
    Case Else: kb = kb & ",F=Undefined"
    End Select
    
    If State.StartClass.Last = 0 Then
        SignalName = "None"
    ElseIf UBound(Classes) = 0 Then 'Classes not initialised
        SignalName = "None"
    Else
        SignalName = Classes(State.StartClass.Last).Name
    End If
    kb = kb & "," & SignalName
    If State.StartClass.Next = 0 Then
        SignalName = "None"
    ElseIf UBound(Classes) = 0 Then 'Classes not initialised
        SignalName = "None"
    Else
        SignalName = Classes(State.StartClass.Next).Name
    End If
    kb = kb & "-" & SignalName
    aGetState = kb
End Function

    Program As Long     '0=No Profile
                        '1=Loading Profile
                        '2=Profile Loaded
                        '3=Start Time Set
                        '4=Start Sequence Commenced
                        '5=Start Sequence Finished
    FunctionKey As Long '0=Disabled
                        '1=Postpone
                        '2=Recall
                        '3=General Recall
                        '4=Finish
    start As defStart   'NextClass, LastClass
#End If

'0=No Profile,1=Loading Profile,2=Profile Loaded
'3=Start Time Set,4=Start Sequence Commenced,5=Start Sequence Finished
Public Function GoProgramState(ByVal NewState As Long) As Boolean
WriteLog "Program " & State.NextEventTime
'I think we should always allow a reset to state 0
'and do the same with all other state.'s
'First Check permitted state changes
    Select Case State.Program
    Case Is = 0         'No Profile
        Select Case NewState
        Case Is = 1
            GoProgramState = True
        End Select
    Case Is = 1         'Loading Profile
        Select Case NewState
        Case Is = 2         'Spash Timer has finished, Load Completed
            GoProgramState = True
        End Select
    Case Is = 2
        Select Case NewState
        Case Is = 1, 3      '1=Reload Profile
            GoProgramState = True
        End Select
    Case Is = 3
        Select Case NewState
        Case Is = 1, 4       'Allow reload profile
            GoProgramState = True
        End Select
    Case Is = 4
        Select Case NewState
        Case Is = 1, 5       'Allow reload profile
            GoProgramState = True
        End Select
    Case Is = 5
        Select Case NewState
        Case Is = 1, 2       'Allow reload profile
            GoProgramState = True
        End Select
    End Select
    
'Second Set the New state requred - any routines called must assume the
'New Program state
    If GoProgramState = True Then
'Set the NewState first so that any subsequent check of the state are correct
        Call SetProgramState(NewState)
        
'Call any Transition Routines, then generate Further Events (Go...)
        Select Case NewState
        Case Is = 1
            'Loading or Reloading Profile (can be done from any State
'Reset all states
            frmMain.KeyPreview = False
            State.Sequence = 0
            Call frmMain.DisplaySequence    'syc update display
            State.Recalls = 0
            State.NextEventTime = 0
            State.StartClass.Last = 0
            State.StartClass.Next = 0
            State.EventPause = 0
            ReDim Keys(0)
WriteLog "LoadProfileTimer.Enabled = " & frmMain.LoadProfileTimer.Enabled
            frmMain.LoadProfileTimer.Enabled = True
        Case Is = 2         'Splash Timer has finished, Load Completed
'            GoLastClassState (0)    'Last=0,Next=1
            Call GoNextClassStarted
        Case Is = 3
            Call frmMain.StartTimeIsSet
'If we want to change the start time after it has been set & before the start sequence
'has started we need to look carefully at how to resset the states
            
'Stops the Start Time being changed before the Satrt Sequence has started
''            frmMain.txtFirstStartTime.Enabled = False
            frmMain.KeyPreview = True
'The Sequence is set to 1, before the Sequence has started
            Call GoSequenceState(1)    'Sequence Not Started
'done in set sequence            Call GoResetKeyState             'Display the Applicable Function Keys
''            Call GoLastClassState(0)    'Set the First Class Start to 1
        Case Is = 4                     'Program Start Sequence Started
            Call GoSequenceState(2)
        End Select
        Call frmMain.DisplayProgram
    Else
        MsgBox "Cannot change " & aProgramState(State.Program) & vbCrLf _
        & "to " & aProgramState(NewState), , "GoProgramState"
    End If
End Function

'Sequence:0=Disabled,1=NotStarted,2=Postpone,3=Recalls,4=Finish
Public Function GoSequenceState(ByVal NewState As Long) As Boolean
'Dim DontResetRecallState As Boolean 'Only if start sequence has started
'First Check permitted state changes
WriteLog "Sequence " & State.NextEventTime
    Select Case State.Sequence
    Case Is = 0
        Select Case NewState
        Case Is = 1         'Disabled to Not Started
            GoSequenceState = True
        End Select
    Case Is = 1
        Select Case NewState
        Case Is = 2         'Sequence Not Started to Postpone
'            DontResetRecallState = True    'This is done when Disabled to NotStarted
            GoSequenceState = True
        End Select
    Case Is = 2
        Select Case NewState
        Case Is = 3         'Postpone to Recalls
            GoSequenceState = True
        End Select
    Case Is = 3     'Recalls
'cancel recall
        Select Case NewState
        Case Is = 2         'Recalls to Postpone (Next Class)
            GoSequenceState = True
        Case Is = 4          'Recalls to Finish
            GoSequenceState = True
        End Select
    End Select
        
'Second Set the New state required - any routines called must assume the
'New Sequence state
    If GoSequenceState = True Then
'Set the NewState first so that any subsequent check of the state are correct
        Call SetSequenceState(NewState)
        
'Call any Transition Routines, then generate Further Events (Go...)
        Select Case NewState
        Case Is = 1     '1=Sequence not started
 'remove functionkeys           Call GoResetKeyState
        Case Is = 2     '2=Postpone
'            If DontResetRecallState = False Then
                Call GoRecallsState(0)  'Calls GoResetKeyState
'            Else
'                Call GoResetKeyState
'            End If
        Case Is = 3     'Recalls
            Call GoRecallsState(1)  'Recall and General Recall
                                    'Calls GoResetKeyState
        Case Is = 4     'Finish
            Call GoRecallsState(0)  'This will Clear Both Keys
                                    'Calls GoResetKeyState
        End Select
'KeyState is always changed
'Note at the start time it must first be set to 0 when postpone disabled
'Then to Recalls
'Display the changes
        Call frmMain.DisplaySequence
    Else
        MsgBox "Cannot change " & aSequenceState(State.Sequence) & vbCrLf _
        & "to " & aSequenceState(NewState), , "GoSequenceState"
    End If
End Function

'0=None,1=Both,2=Recall,3=General Recall
'O,1 are called by GoSequence State
Public Function GoRecallsState(ByVal NewState As Long) As Boolean
WriteLog "Recalls " & State.NextEventTime
        
    If NewState = State.Recalls Then
        If NewState = 0 Then
'Occurs when Recalls is set to 0 before StartSequence commences & postpone
'has not been set because the start time is not set because Events clicked
            Exit Function
        End If
    End If
    
    Select Case State.Recalls
    Case Is = 0         'Not in Recalls State
        Select Case NewState
        Case Is = 1     'None to Both
            GoRecallsState = True
        End Select
    Case Is = 1     'Both
        Select Case NewState
        Case Is = 0     'Both to None (Neither Recall Flag has been raised)
            GoRecallsState = True
        Case Is = 2     'Both to Recall
'Remove the Other Recall
'            Keys(KeyNameToKeyNo("General Recall")).State = 0
'            Call SetKeyState(KeyNameToKeyNo("General Recall"), False)
            GoRecallsState = True
        Case Is = 3     'Both to General Recall
'Remove the Other Recall
'            Call SetKeyState(KeyNameToKeyNo("Recall"), False)
'            Keys(KeyNameToKeyNo("Recall")).State = 0
            GoRecallsState = True
        End Select
    Case Is = 2     'Recall
        Select Case NewState
        Case Is = 0 'Recall to None
            GoRecallsState = True
        End Select
    Case Is = 3     'General Recall
        Select Case NewState
        Case Is = 0 'General Recall to None
            GoRecallsState = True
        End Select
    End Select
    
'If the Recalls state changes, the key state will change
    If GoRecallsState = True Then
        If NewState = 3 Then
'Leave Last start as next
            State.StartClass.Last = State.StartClass.Last
        End If
        Call SetRecallsState(NewState)
'remove functionkeys        Call GoResetKeyState 'After NewState is set
    Else
        MsgBox "Cannot change " & aRecallsState(State.Recalls) & vbCrLf _
        & "to " & aRecallsState(NewState), , "GoRecallsState"
    End If
End Function

'Called whenever a Class is started by Evts
'By ProgramState when Splash is removed (State.ClassStart.Next=0)
'By GeneralRecall
Public Function GoNextClassStarted() As Boolean
Dim Restart As Boolean
WriteLog "NextClassStarted " & State.NextEventTime

    If State.StartClass.Next = State.StartClass.Last + 1 Then
        GoNextClassStarted = True
    ElseIf State.StartClass.Next = 0 Then
        GoNextClassStarted = True
    End If
        
    If GoNextClassStarted = True Then
        Select Case State.StartClass.Next
        Case Is = 0     'Initial Call
            Call SetLastStartClass(0)   'Next Class Start is set to 1
        Case Is > 0
            Call SetLastStartClass(State.StartClass.Next)   'Set both Last and Next
            Call GoSequenceState(3)     'Recalls will also trigger function key changes
        End Select

'Move to SetLastClassStart Display the changes
'        Call frmMain.DisplayLastNextStartClass
'Keep this time (in case of General Recall) to display time since the false start
        State.GrStartTime = State.NextEventTime
    Else
        MsgBox "Cannot change " & Classes(State.StartClass.Last).Name & vbCrLf _
        & "to " & Classes(State.StartClass.Next).Name, , "GoLastClassState"
    End If
End Function

'Only called By GoLowerGeneralRecall
Public Function GoLastClassStarted(ByVal LastClassStarted As Long) As Boolean  'Not used for SYC
Dim Restart As Boolean
WriteLog "LastClassStarted " & State.NextEventTime

'A class must have started for a General Recall
    If State.StartClass.Last > 0 Then
'They should be the same when GeneralRecall is lowered
        If State.StartClass.Last = State.StartClass.Next Then
            If State.StartClass.Next = State.StartClass.Last Then
                GoLastClassStarted = True
            End If
        End If
    End If
    If GoLastClassStarted = True Then
        Call SetLastStartClass(State.StartClass.Last - 1) 'Set both Last and Next
        Call GoSequenceState(2)     'Postpone will also trigger function key changes

'Display the changes
       Call frmMain.DisplayLastNextStartClass
    Else
        MsgBox "Cannot change " & Classes(State.StartClass.Last).Name & vbCrLf _
        & "to " & Classes(State.StartClass.Next).Name, , "GoLastClassState"
    End If
End Function

'Called whenever a Class is started by Evts
'By ProgramState when Splash is removed with (0)
'By GeneralRecall
Public Function GoLastClassState(ByVal LastClassStarted As Long) As Boolean  'Not used for SYC
Dim Restart As Boolean
WriteLog "LastClassState " & State.NextEventTime

'First Check permitted state changes
        Select Case LastClassStarted
        Case Is = 0
            GoLastClassState = True
        Case Is = State.StartClass.Last
'Restarting Class
'Stop
            Restart = True
            GoLastClassState = True
        Case Is = State.StartClass.Next
'Next Class is starting
            GoLastClassState = True
        End Select

'        If ReStart = True Then
'Stop
'        End If

'Second Set the New state required - any routines called must assume the
'New Sequence state
    If GoLastClassState = True Then
'Set the NewClass first so that any subsequent check of the state are correct
        Call SetLastStartClass(LastClassStarted)   'Set both Last and Next
'Call any Transition Routines, then generate Further Events (Go...)
        Select Case LastClassStarted
        Case Is = 0
'            frmMain.lblTimeFromLastStart.Visible = False
        Case Is > 0
'Now create any other events required for all starts
            Call GoSequenceState(3)     'Recalls will also trigger function key changes
        End Select

'Display the changes
        Call frmMain.DisplayLastNextStartClass
    Else
        MsgBox "Cannot change " & Classes(State.StartClass.Last).Name & vbCrLf _
        & "to " & Classes(LastClassStarted).Name, , "GoLastClassState"
    End If
    
        
    
#If False Then
    If NewClass = 0 Then    'Resetting the Last Class started to 0
'Only Reset the Next Class
        State.StartClass.Next = 1
        GoLastClassState = True
    Else
        If NewClass = State.StartClass.Last + 1 Then
            Call frmMain.LoadStart(NewClass)
            Call GoRecallsState(1)      'Both
'                Call TransitionSubRoutine '(SetLastClassState(NewClass) on Exit)
            GoLastClassState = True
        End If
    End If
    
    If GoLastClassState = True Then
        Call frmMain.DisplayLastNextStartClass
    End If
    
    If GoLastClassState = False Then
        MsgBox "Cannot change " & Classes(State.StartClass.Last).Name & vbCrLf _
        & "to " & Classes(NewClass).Name, , "GoLastClassState"
    End If
#End If
End Function

'Set the Key states acording to the Sequence State
'0=Disabled,1=Postpone,2=Recall,3=General Recall, 4=Finish
Public Function GoResetKeyState() As Boolean  'Not used for SYC
Dim KeyNo As Long
Dim NewKeys() As defKey
WriteLog "Key " & State.NextEventTime

    ReDim NewKeys(UBound(Keys))
    Select Case State.Sequence      '0=NotStarted,1=Postpone,2=Recalls,3=Finish
    Case Is = 0     'Disabled
'Exit Function 'SYC dont enable any function keys
'The Postpone has been enabled before the Sequence has started
        NewKeys(1).State = 0
        NewKeys(2).State = 0
    Case Is = 1     'Not started
        NewKeys(1).State = 1
'        NewKeys(1).State = 0    'syc dont use postpone
        NewKeys(2).State = 0
    Case Is = 2     'Postpone
        NewKeys(1).State = 1
'        NewKeys(1).State = 0    'syc dont use postpone
        NewKeys(2).State = 0
                    'State.Recalls should be 0
    Case Is = 3     'Recalls
'Exit Function 'SYC dont enable any function keys
        Select Case State.Recalls '0=None,1=Both,2=Recall,3=General Recall
            Case Is = 0
                NewKeys(1).State = 0
                NewKeys(2).State = 0
            Case Is = 1
                NewKeys(1).State = 2
                NewKeys(2).State = 3
            Case Is = 2
                NewKeys(1).State = 2
                NewKeys(2).State = 0
            Case Is = 3
                NewKeys(1).State = 0
                NewKeys(2).State = 3
        End Select
    Case Is = 4     'Finish
        NewKeys(1).State = 4
        NewKeys(2).State = 0
    End Select
    
    NewKeys(1).Cancel = False
    NewKeys(2).Cancel = False
    
    For KeyNo = 1 To UBound(Keys)
        If Keys(KeyNo).State <> NewKeys(KeyNo).State Then
           Call SetKeyState(KeyNo, NewKeys(KeyNo).State)    'DisplaysKeys
            GoResetKeyState = True
        End If
        If Keys(KeyNo).Cancel <> NewKeys(KeyNo).Cancel Then
           Call SetKeyCancel(KeyNo, NewKeys(KeyNo).Cancel)    'DisplaysKeys
            GoResetKeyState = True
        End If
    Next KeyNo
    
    
    If GoResetKeyState = False Then
        MsgBox "Key State not changed", , "GoResetKeyState"
    End If
    
End Function

Public Function GoToggleKey(ByVal KeyNo)  'Not used for SYC
        Call SetKeyCancel(KeyNo, Not Keys(KeyNo).Cancel)
        Call frmMain.DisplayKeys
End Function

'Sequence:0=Disabled,1=NotStarted,2=Postpone,3=Recalls,4=Finish
Public Function GoRaisePostpone() As Boolean  'Not used for SYC
Dim Idx As Long
WriteLog "RaisePostpone " & State.NextEventTime
    
'If before First Start all classes are Postponed, so dont set Class flag under postpone
    If State.StartClass.Last > 0 Then
        Idx = SignalFromName("Postpone Class")
        Set SignalAttributes(Idx).Image = SignalAttributes(Classes(State.StartClass.Next).Signal).Image
    End If
        
    Idx = SignalFromName("Postpone")
    Select Case State.Sequence
    Case Is = 1     'Start Sequence not started
        Call frmMain.RaiseRequest(Idx)
        GoRaisePostpone = True
    Case Is = 2     'Start Sequence started
'Reset Class start and (will start pause so start will be 1 min after Postpone is dropped)
        Call frmMain.ClassRestart(State.StartClass.Next)
        Call frmMain.RaiseRequest(Idx)
        State.EventPause = -1
        GoRaisePostpone = True
'        Stop
    End Select
    
    If GoRaisePostpone = False Then
MsgBox "Cannot Raise Postpone " & aProgramState(State.Program), , "GoRaisePostpone"
    End If
End Function

'Only Called from KeyDown
'Sequence:0=Disabled,1=NotStarted,2=Postpone,3=Recalls,4=Finish
Public Function GoLowerPostpone() As Boolean  'Not used for SYC
Dim Idx As Long
WriteLog "LowerPostpone " & State.NextEventTime

    Idx = SignalFromName("Postpone")
    If SignalAttributes(Idx).Flag.pos > 0 Then
        Select Case State.Sequence
        Case Is = 1 'Before Start sequence, no action
            Call frmMain.LowerRequest(Idx)
            GoLowerPostpone = True
        Case Is = 2
            Call frmMain.LowerRequest(Idx)
            State.EventPause = 0
            GoLowerPostpone = True
        End Select
        Idx = SignalFromName("Postpone Class")
        If Idx > 0 Then 'May not have a class flag up prior to start
            Set SignalAttributes(Idx).Image = Nothing
        End If
    End If
    If GoLowerPostpone = False Then
MsgBox "Cannot Lower Postpone " & aProgramState(State.Program), , "GoLowerPostpone"
    End If
End Function

'Called when Recall (F5) Clicked
Public Function GoRaiseRecall()
Dim Idx As Long
WriteLog "RaiseRecall " & State.NextEventTime

    Idx = SignalFromName("Recall Class")
    Set SignalAttributes(Idx).Image = SignalAttributes(Classes(State.StartClass.Last).Signal).Image
    Idx = SignalFromName("Recall")
    Call frmMain.RaiseRequest(Idx)
    Call GoRecallsState(2)
End Function 'Called 30 secs after start

'Called if RecallFunction Manually called or from Evts after 4 mins
Public Function GoLowerRecall() As Boolean '(ByVal Class As Long, Optional NotLastClass As Boolean)
Dim Idx As Long
WriteLog "LowerRecall " & State.NextEventTime

    Idx = SignalFromName("Recall")
    If SignalAttributes(Idx).Flag.pos > 0 Then
        Select Case State.Recalls
        Case Is = 2
            GoLowerRecall = True
        End Select
    End If
        
    If GoLowerRecall = True Then
        Call frmMain.LowerRequest(Idx)
        State.EventPause = 0
'Restart
    
    Else
MsgBox "Incorrect Recalls State " & aRecallsState(State.Recalls), , "GoLowerRecall"
    End If
End Function

Public Function GoRaiseGeneralRecall() '(ByVal Class As Long)
Dim Idx As Long
WriteLog "RaiseGeneralRecall " & State.NextEventTime

    Idx = SignalFromName("Recall Class")
    Set SignalAttributes(Idx).Image = SignalAttributes(Classes(State.StartClass.Last).Signal).Image
'    Call frmMain.ClassRestart(State.StartClass.Last)    'NextClassStart
    Idx = SignalFromName("General Recall")
    Call frmMain.RaiseRequest(Idx)
'syc treat General Recall same as Recall    State.                   = -1
    Call GoRecallsState(3)  'General Recall
'    Call frmMain.DisplayLastNextStartClass

End Function

Public Function GoLowerGeneralRecall() As Boolean
Dim Idx As Long
WriteLog "LowerGeneralRecall " & State.NextEventTime


    Idx = SignalFromName("General Recall")
    If SignalAttributes(Idx).Flag.pos > 0 Then
        Select Case State.Recalls
        Case Is = 3
            GoLowerGeneralRecall = True
        End Select
    End If
        
    If GoLowerGeneralRecall = True Then
        Call frmMain.LowerRequest(Idx)
        State.EventPause = 0
'Reset the LastClassStart from the Recalled class to the one before
'        If State.StartClass.Last = 1 Then
'            Call GoSequenceState(1)  'Not yet started
'        End If
'syc        Call GoLastClassStarted(State.StartClass.Last - 1)
'syc        frmMain.lblTimeToNextStart.Visible = True
    Else
MsgBox "Incorrect Recalls State " & aRecallsState(State.Recalls), , "GoLowerGeneralRecall"
    End If
End Function

#If False Then  'Template
Public Function GoXXState(ByVal NewState As Long) As Boolean
    Select Case State.XX
    Case Is = 0         'Forms No Profile
            Select Case NewState
            Case Is = 0
                Call TransitionSubRoutine '(SetXXState(NewState) on Exit)
                GoXXState = True
            Case Else
'Stop
            End Select

    Case Else
'Stop
    End Select
    
    If GoXXState = False Then
        MsgBox "Cannot change " & aXXState(State.XX) & vbCrLf _
        & "to " & aXXState(NewState), , "GoXXState"
    End If
End Function
#End If

'0=No Profile,1=Loaded,2=Profile Loaded,3=StartTimeSet,4=SeqStarted,5=SeqFinished
Public Function SetProgramState(ByVal ReqState As Long)
    If State.Program = ReqState Then
MsgBox "State.Program " & aProgramState(ReqState) & " not changed", , "SetProgramState"
    Else
        State.Program = ReqState
        Call frmMain.DisplayFirstStartTime
        WriteLog vbTab & aProgramState(ReqState)
    End If
End Function

'Sequence:0=Disabled,1=Sequence NotStarted,2=Postpone,3=Recalls,4=Finish
Public Function SetSequenceState(ByVal ReqState As Long)
    If State.Sequence = ReqState Then
MsgBox "State.Sequence " & aSequenceState(ReqState) & " not changed", , "SetSequenceSate"
        Exit Function
    Else
        State.Sequence = ReqState
        Call frmMain.DisplaySequence
        WriteLog vbTab & aSequenceState(ReqState)
    End If
End Function

'0=None,1=Both,2=Recall,3=General Recall
Public Function SetRecallsState(ByVal ReqState As Long)
    If State.Recalls = ReqState Then
MsgBox "State.Recalls " & aRecallsState(ReqState) & " not changed", , "SetRecallsState"
        Exit Function
    Else
        State.Recalls = ReqState
        Call frmMain.DisplayRecalls
        WriteLog vbTab & aRecallsState(ReqState)
    End If
End Function

'Also sets the Next Class start to Last + 1
Public Function SetLastStartClass(ByVal Class As Long)
Dim NextClass As Long

'Calc Next Start first to check if anything will change
        Select Case Class
        Case Is < UBound(Classes): NextClass = Class + 1
        Case Is = UBound(Classes): NextClass = 0
        End Select

    If State.StartClass.Last = Class And State.StartClass.Next = NextClass Then
'Invalid Class will case error
MsgBox "Last/Next Start Class " & Classes(Class).Name & " not changed", , "SetStartClass"
        Exit Function
    Else
'Display the changes
'SYC        Call frmMain.DisplayLastNextStartClass
        If State.StartClass.Last <> Class Then
            State.StartClass.Last = Class
            WriteLog vbTab & "Last=" & Classes(Class).Name
        End If
        If State.StartClass.Next <> NextClass Then
            State.StartClass.Next = NextClass
            WriteLog vbTab & "Next=" & Classes(NextClass).Name
        End If
    End If
        Call frmMain.DisplayLastNextStartClass  'SYC
End Function

Public Function SetKeyClass_old(ByVal KeyNo As Long, ByVal Class As Long)
Dim i As Long

    If KeyNo < 1 Or KeyNo > UBound(Keys) Then
MsgBox "Invalid Key " & KeyNo, , "SetKeyClass"
        Exit Function
    End If
    
#If False Then 'Wont complile
    If Keys(KeyNo).Class = Class Then
MsgBox "Key [" & Keys(KeyNo).Name & "] not changed", , "SetKeyClass"
        Exit Function
    Else
        Keys(KeyNo).Class = Class
    End If
#End If
End Function

Public Function SetKeyFunctionCall(ByVal KeyNo, ByVal FunctionCall As String)
'None,GoRaisePostpone,GoLowerPostpone,GoRaiseRecall,GoLowerRecall
'GoRaiseGeneralRecall,GoLowerGeneralRecall,GoRaiseFinish

End Function

'0=Disabled,1=Postpone,2=Recall,3=General Recall, 4=Finish
Public Function SetKeyState(ByVal KeyNo, ByVal ReqState As Long)

    If KeyNo < 1 Or KeyNo > UBound(Keys) Then
MsgBox "Invalid Key " & KeyNo, , "SetKeyState"
        Exit Function
    End If
    
    If Keys(KeyNo).State <> ReqState Then
        Keys(KeyNo).State = ReqState
        Keys(KeyNo).Cancel = False  'Reset
        Call frmMain.DisplayKeys
        WriteLog vbTab & "Key " & Keys(KeyNo).KeyName & "=" & aKeyState(Keys(KeyNo).State)
    Else
MsgBox "Key [" & Keys(KeyNo).KeyName & "] not changed", , "SetKeyState"
    End If
End Function

Public Function SetKeyCancel(ByVal KeyNo, ByVal KeyCancel As Boolean)
    If KeyNo < 1 Or KeyNo > UBound(Keys) Then
MsgBox "Invalid Key " & KeyNo, , "SetKeyState"
        Exit Function
    End If
    If Keys(KeyNo).Cancel <> KeyCancel Then
        Keys(KeyNo).Cancel = KeyCancel
        WriteLog vbTab & "Key " & Keys(KeyNo).KeyName & " Cancel=" & Keys(KeyNo).Cancel
    Else
MsgBox "Key [" & Keys(KeyNo).KeyName & "] not changed", , "SetKeyCancel"
    End If
End Function

Private Function KeyNameToKeyNo(KeyName As String) As Long
Dim KeyNo As Long
    If IsKeysInitialised(Keys) = True Then
        For KeyNo = 1 To UBound(Keys)
            If aKeyState(Keys(KeyNo).State) = KeyName Then
                Exit For
            End If
        Next KeyNo
    End If
End Function

Public Function ClearKeyStates() As Long  'Not used for SYC
Dim KeyNo As Long
    If IsKeysInitialised(Keys) = True Then
        For KeyNo = 1 To UBound(Keys)
            Keys(KeyNo).State = 0
        Next KeyNo
    End If
    Call frmMain.DisplayKeys
        WriteLog vbTab & "Key " & Keys(KeyNo).KeyName & "=" & aKeyState(Keys(KeyNo).State)
End Function

'Variant to handle Long and Integer
Public Function cbdefault(Idx As Long) As Long
    With frmMain.Commands(Idx)
        If .Enabled = True Then
            cbdefault = cbEnabled       'vbYellow
        Else
            cbdefault = cbDisabled      '&H8000000F
        End If
    End With
End Function

